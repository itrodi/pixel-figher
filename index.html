<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Pixel Fight </title>
    <script src="https://unpkg.com/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        font-family: "Courier New", monospace;
      }

      body {
        overflow: hidden;
        background-color: #181818;
        height: 100vh;
        width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #game-container {
        position: relative;
        width: 100%;
        height: 100%;
        max-width: 500px;
        max-height: 800px;
        overflow: hidden;
        background-color: #0a0a2a; /* Dark blue background */
      }

      #game-screen {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
      }

      #score-container {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        font-size: 16px;
        color: #ffffff;
        font-weight: bold;
      }

      #wave-container {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        font-size: 16px;
        color: #ffffff;
        font-weight: bold;
      }

      #health-container {
        position: absolute;
        top: 36px;
        left: 10px;
        height: 20px;
        width: 150px;
        background-color: #333333;
        border: 2px solid #444444;
        z-index: 10;
        overflow: hidden;
      }

      #health-bar {
        height: 100%;
        width: 100%;
        background-color: #00ff00;
        transition: width 0.3s;
      }

      #weapon-container {
        position: absolute;
        top: 36px;
        right: 10px;
        z-index: 10;
        font-size: 14px;
        color: #ffcc00;
        font-weight: bold;
      }

      #bomb-container {
        position: absolute;
        top: 62px;
        right: 10px;
        z-index: 10;
        font-size: 14px;
        color: #ff44ff;
        font-weight: bold;
      }

      #music-toggle {
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 10;
        font-size: 12px;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
      }

      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #0a0a2a;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }

      .title {
        font-size: 24px;
        font-weight: bold;
        color: #ffffff;
        margin-bottom: 20px;
        text-align: center;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .button {
        padding: 10px 20px;
        font-size: 16px;
        font-weight: bold;
        background-color: #4444ff;
        color: #ffffff;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
      }

      .button:active {
        transform: scale(0.95);
      }

      #player {
        position: absolute;
        width: 24px;
        height: 24px;
        background-color: #00ff00;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        border-radius: 3px;
        z-index: 5;
      }

      .ally {
        position: absolute;
        width: 16px;
        height: 16px;
        background-color: #22cc22;
        border-radius: 3px;
        z-index: 4;
      }

      .shield {
        position: absolute;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 3px solid #4444ff;
        top: -4px;
        left: -4px;
        opacity: 0.7;
        display: none;
        animation: shieldPulse 1s infinite alternate;
      }

      @keyframes shieldPulse {
        0% {
          box-shadow: 0 0 5px #4444ff;
        }
        100% {
          box-shadow: 0 0 15px #4444ff;
        }
      }

      .enemy {
        position: absolute;
        width: 20px;
        height: 20px;
        background-color: #ff0000;
        border-radius: 3px;
      }

      .health-bar-container {
        position: absolute;
        width: 30px;
        height: 4px;
        background-color: #333333;
        bottom: -8px;
        left: -3px;
      }

      .health-bar {
        height: 100%;
        background-color: #ff3333;
        width: 100%;
      }

      .bullet {
        position: absolute;
        width: 4px;
        height: 10px;
        background-color: #ffff00;
        border-radius: 2px;
      }

      .bullet.level2 {
        background-color: #ffaa00;
        width: 5px;
        height: 12px;
      }

      .bullet.level3 {
        background-color: #ff5500;
        width: 6px;
        height: 14px;
      }

      .enemy-bullet {
        position: absolute;
        width: 4px;
        height: 8px;
        background-color: #ff5555;
        border-radius: 2px;
      }

      .power-up {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        animation: pulsePowerUp 0.8s infinite alternate;
      }

      .power-up.shield {
        background-color: #4444ff;
      }

      .power-up.ally {
        background-color: #22cc22;
      }

      .power-up.weapon {
        background-color: #ffcc00;
      }

      .power-up.health {
        background-color: #ff4444;
      }

      .power-up.bomb {
        background-color: #ff44ff;
      }

      @keyframes pulsePowerUp {
        0% {
          transform: scale(1);
          opacity: 0.8;
        }
        100% {
          transform: scale(1.2);
          opacity: 1;
        }
      }

      .explosion {
        position: absolute;
        width: 30px;
        height: 30px;
        background-color: #ff8800;
        border-radius: 50%;
        opacity: 0.8;
        animation: explode 0.3s forwards;
      }

      .bomb-explosion {
        position: absolute;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, #ff44ff 0%, transparent 70%);
        border-radius: 50%;
        opacity: 0.8;
        animation: bombExplode 0.5s forwards;
      }

      @keyframes explode {
        0% {
          transform: scale(0.5);
          opacity: 1;
        }
        100% {
          transform: scale(1.5);
          opacity: 0;
        }
      }

      @keyframes bombExplode {
        0% {
          transform: scale(0.5);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.5);
          opacity: 1;
        }
        100% {
          transform: scale(2);
          opacity: 0;
        }
      }

      .particle {
        position: absolute;
        width: 4px;
        height: 4px;
        background-color: #ff4400;
        border-radius: 50%;
      }

      .star {
        position: absolute;
        width: 2px;
        height: 2px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
      }

      .flash {
        animation: flashScreen 0.2s;
      }

      @keyframes flashScreen {
        0% {
          background-color: #0a0a2a;
        }
        50% {
          background-color: #ff0000;
        }
        100% {
          background-color: #0a0a2a;
        }
      }

      .wave-notification {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffffff;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        z-index: 50;
        opacity: 0;
        animation: fadeInOut 2s forwards;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateX(-50%) scale(0.8);
        }
        50% {
          opacity: 1;
          transform: translateX(-50%) scale(1);
        }
        90% {
          opacity: 1;
          transform: translateX(-50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateX(-50%) scale(1.1);
        }
      }

      .score-popup {
        position: absolute;
        color: #ffffff;
        font-size: 12px;
        font-weight: bold;
        z-index: 20;
        opacity: 0;
        animation: floatUp 1s forwards;
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-20px);
        }
      }

      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #0a0a2a;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
      }

      .loading-text {
        font-size: 18px;
        font-weight: bold;
        color: #ffffff;
        margin-top: 20px;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #222244;
        border-radius: 50%;
        border-top-color: #4444ff;
        animation: spinner 1s linear infinite;
      }

      @keyframes spinner {
        to {
          transform: rotate(360deg);
        }
      }

      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 150;
      }

      .game-over-title {
        font-size: 32px;
        font-weight: bold;
        color: #ff0000;
        margin-bottom: 20px;
        text-align: center;
      }

      .final-score {
        font-size: 24px;
        color: #ffffff;
        margin-bottom: 30px;
        text-align: center;
      }

      .distance-traveled {
        font-size: 18px;
        color: #ffffff;
        margin-bottom: 20px;
        text-align: center;
      }

      .enemies-defeated {
        font-size: 18px;
        color: #ffffff;
        margin-bottom: 20px;
        text-align: center;
      }

      .road {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 20px;
        background-color: #333333;
      }

      .distance-marker {
        position: absolute;
        bottom: 25px;
        font-size: 12px;
        color: #ffffff;
        width: 2px;
        height: 8px;
        background-color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="game-screen">
        <div id="score-container">SCORE: 0</div>
        <div id="wave-container">WAVE: 1</div>
        <div id="health-container">
          <div id="health-bar"></div>
        </div>
        <div id="weapon-container">WEAPON: LV.1</div>
        <div id="bomb-container">BOMBS: 0</div>
        <div id="music-toggle">MUSIC: ON</div>

        <div class="road"></div>

        <div id="player">
          <div class="shield" id="shield"></div>
        </div>
      </div>

      <div id="start-screen">
        <div class="title">PIXEL<br />FIGHT</div>
        <div style="color: #ffffff; text-align: center; margin: 0 20px">
          Lead your pixel through waves of enemy pixels!<br />
          Touch left/right sides of screen to move.<br />
          Auto-fire when enemies are in range.<br />
          Double tap to make use of the bomb <br />
          arrow keys to move and space to use bomb on pc<br />
          Collect power-ups to survive the battle!
        </div>
        <button id="start-button" class="button">START GAME</button>
      </div>

      <div id="game-over-screen">
        <div class="game-over-title">GAME OVER</div>
        <div class="final-score" id="final-score">FINAL SCORE: 0</div>
        <div class="enemies-defeated" id="enemies-defeated">ENEMIES DEFEATED: 0</div>
        <div class="wave-reached" id="wave-reached">WAVE REACHED: 0</div>
        <button id="restart-button" class="button">PLAY AGAIN</button>
      </div>

      <div id="loading-screen" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading...</div>
      </div>
    </div>

    <script>
      // Background music
      const bgMusic = new Audio(
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Pz7LBDdo4beh/be-more-serious-loop-275528-4yiRgTDdTCftlaFp3X5Z92GUCHXzTm.mpeg?fXHA",
      );
      bgMusic.loop = true;
      bgMusic.volume = 0.2;

      // Game configuration
      const config = {
        playerHealth: 100,
        playerSpeed: 5,
        bulletSpeed: 8,
        enemyBulletSpeed: 5,
        enemySpeed: 1.4, // Increased from 1.2 for more intensity
        enemyCount: {
          initial: 15, // Increased from 5 to 15 for more intensity from start
          incrementPerWave: 3, // Increased from 2 for steeper difficulty curve
          max: 35, // Increased from 30 for higher maximum
        },
        enemyShootChance: 0.02, // Increased from 0.01 for more bullets/intensity
        powerUpChance: 0.01, // REDUCED from 0.1 to 0.05 for fewer power-ups
        baseEnemyDamage: 12, // Increased from 10 for more challenge
        shieldDuration: 9000, // Reduced from 8000 for less protection time
        invincibilityTime: 1500, // Kept the same
        allyCount: 0,
        maxAllies: 9, // Increased from 6 to let skilled players get more allies
        progressSpeed: 1.5, // Speed at which the player progresses forward
        autoShootDelay: 500, // ms between auto-shots
        waveAdvanceDistance: 300, // Distance to advance to the next wave
        scoreValues: {
          normalEnemy: 5, // REDUCED from 10 to 5 per request
          fastEnemy: 10, // REDUCED from 20 to 10
          toughEnemy: 15, // REDUCED from 30 to 15
          zigzagEnemy: 12, // REDUCED from 25 to 12
        },
        enemyHealth: {
          normal: 2,
          fast: 1,
          tough: 5,
          zigzag: 3,
        },
        starCount: 50, // Background stars
        difficultyMultiplier: 1.2, // Increased from 1.15 for faster ramp-up
        screenWidth: 0, // Will be set during initialization
        laneCount: 5, // Number of lanes
        laneSafety: 100, // Distance from sides for valid lanes
        healthDropChance: 0.01, // REDUCED from 0.05 to 0.03 for fewer health drops
        shieldDropChance: 0.08, // REDUCED from 0.15 to 0.08 for fewer shield drops
        bombDropChance: 0.04, // REDUCED from 0.05 to 0.04 for fewer bomb drops
        allyDropChance: 0.12, // NEW - dedicated chance for ally drops (higher than others)
        weaponUpgradeChance: 0.06, // REDUCED from 0.075 to 0.06 for fewer weapon upgrades
        damageMultiplierAfterWave3: 1.5, // Unchanged
        bulletDamage: {
          // Damage per weapon level
          1: 1,
          2: 2,
          3: 3,
        },
        bombDamageRadius: 100, // Pixels (explosion radius)
        allyFormationGap: 40, // Gap between allies in formation
        waveClearBonusMultiplier: 25, // REDUCED from 50 to 25 for lower scoring
      };

      // Game state
      const game = {
        state: "loading",
        score: 0,
        distance: 0,
        currentDistance: 0, // Distance within current wave
        enemiesDefeated: 0,
        health: config.playerHealth,
        wave: 1,
        lastWaveChange: 0,
        player: {
          x: 0,
          y: 0,
          width: 24,
          height: 24,
          lane: 2, // Middle lane (0-4)
          element: null,
          shielded: false,
          invincible: false,
          moving: false, // Whether player is advancing forward
          weaponLevel: 1, // New: weapon level (1-3)
          bombCount: 0, // New: number of bombs player has
        },
        allies: [],
        enemies: [],
        bullets: [],
        enemyBullets: [],
        powerUps: [],
        particles: [],
        stars: [],
        lanes: [], // Lane positions
        keys: {
          left: false,
          right: false,
        },
        touch: {
          active: false,
        },
        animationFrameId: null,
        lastUpdateTime: 0,
        farcadeInitialized: false,
        shieldTimer: null,
        lastAutoShoot: 0,
        hasEnemies: false, // Flag to track if enemies are present
        allEnemiesDefeated: false, // Flag to track if all enemies are defeated
        musicMuted: false, // Flag for background music
      };

      // Audio
      const audio = {
        isMuted: false,
        sounds: {
          shoot: new Audio(
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Pz7LBDdo4beh/shooting-sound-fx-159024-E4IGVcUkuYVQuAW0MR0h6gduRwjtcO.mpeg?0VEa",
          ),
          enemyShoot: new Audio("https://assets.codepen.io/21542/sfx_weapon_singleshot8.wav"),
          hit: new Audio("https://assets.codepen.io/21542/sfx_deathscream_alien1.wav"),
          playerHit: new Audio("https://assets.codepen.io/21542/sfx_deathscream_human4.wav"),
          powerUp: new Audio(
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Pz7LBDdo4beh/bonus-points-190035-mRExh6Erfx6SVb7Pn7pqzNZR9l9rDT.mpeg?xpp4",
          ),
          newAlly: new Audio("https://assets.codepen.io/21542/sfx_sounds_powerup6.wav"),
          gameOver: new Audio("https://assets.codepen.io/21542/sfx_sound_shutdown1.wav"),
          newWave: new Audio("https://assets.codepen.io/21542/sfx_sounds_fanfare3.wav"),
          bomb: new Audio(
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Pz7LBDdo4beh/a-bomb-139689-CUKc93EiEysZZRP32gtBSPQhfZX6yk.mpeg?D0sK",
          ), // Will substitute with a similar sound
          upgrade: new Audio(
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Pz7LBDdo4beh/bonus-points-190035-mRExh6Erfx6SVb7Pn7pqzNZR9l9rDT.mpeg?xpp4",
          ), // Will substitute with a similar sound
        },
        play: function (soundName) {
          if (this.isMuted) return;
          try {
            const sound = this.sounds[soundName];
            if (sound) {
              if (sound.paused) {
                sound.currentTime = 0;
                sound.volume = 0.3;
                sound.play().catch((err) => console.log("Audio playback prevented:", err));
              } else {
                // If the sound is already playing, create a new Audio instance
                const newSound = new Audio(sound.src);
                newSound.volume = 0.3;
                newSound.play().catch((err) => console.log("Audio playback prevented:", err));
              }
            }
          } catch (error) {
            console.log("Sound playback failed:", error);
          }
        },
        setMuted: function (muted) {
          this.isMuted = muted;

          // Also handle background music
          if (muted) {
            bgMusic.pause();
          } else if (game.state === "playing" && !game.musicMuted) {
            bgMusic.play().catch((err) => console.log("Music resume failed:", err));
          }
        },
      };

      // Music toggle handler
      function toggleMusic() {
        game.musicMuted = !game.musicMuted;
        document.getElementById("music-toggle").textContent = `MUSIC: ${game.musicMuted ? "OFF" : "ON"}`;

        if (game.musicMuted) {
          bgMusic.pause();
        } else if (game.state === "playing" && !audio.isMuted) {
          bgMusic.play().catch((err) => console.log("Music toggle failed:", err));
        }
      }

      // Functions to preload sounds
      function preloadSounds() {
        for (const key in audio.sounds) {
          const sound = audio.sounds[key];
          sound.load();
          sound.volume = 0;
          sound
            .play()
            .then(() => {
              sound.pause();
              sound.currentTime = 0;
              sound.volume = 0.3;
            })
            .catch((err) => {
              console.log("Audio preload interrupted:", err);
            });
        }

        // Also preload background music
        bgMusic.load();
      }

      // Initialize the game
      function initGame() {
        document.getElementById("loading-screen").style.display = "flex";
        setupEventListeners();
        createStars();
        preloadSounds();
        initFarcadeSDK();

        // Get screen dimensions
        const gameScreen = document.getElementById("game-screen");
        config.screenWidth = gameScreen.clientWidth;

        // Initialize lane positions
        initializeLanes();

        // Set up music toggle
        document.getElementById("music-toggle").addEventListener("click", toggleMusic);

        setTimeout(() => {
          document.getElementById("loading-screen").style.display = "none";
          game.state = "start";
        }, 1500);
      }

      function initializeLanes() {
        // Calculate lane positions
        game.lanes = [];
        const laneWidth = (config.screenWidth - 2 * config.laneSafety) / (config.laneCount - 1);

        for (let i = 0; i < config.laneCount; i++) {
          game.lanes.push(config.laneSafety + i * laneWidth);
        }
      }

      function initFarcadeSDK() {
        try {
          if (window.FarcadeSDK) {
            // Set up Farcade SDK event handlers
            window.FarcadeSDK.on("play_again", () => {
              if (game.state === "gameOver") {
                restartGame();
              }
            });

            window.FarcadeSDK.on("toggle_mute", (data) => {
              audio.setMuted(data.isMuted);
            });

            // Mark game as ready
            window.FarcadeSDK.singlePlayer.actions.ready();

            game.farcadeInitialized = true;
            console.log("Farcade SDK initialized");
          } else {
            console.warn("Farcade SDK not available");
          }
        } catch (e) {
          console.error("Error initializing Farcade SDK:", e);
        }
      }

      function triggerHapticFeedback() {
        if (game.farcadeInitialized && window.FarcadeSDK) {
          try {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          } catch (e) {
            console.warn("Haptic feedback failed:", e);
          }
        }
      }

      function setupEventListeners() {
        document.getElementById("start-button").addEventListener("click", startGame);
        document.getElementById("restart-button").addEventListener("click", restartGame);

        // Touch controls - touch left or right side of screen to move
        document.getElementById("game-screen").addEventListener("touchstart", (e) => {
          if (game.state !== "playing") return;

          const touch = e.touches[0];
          const screenWidth = document.getElementById("game-screen").clientWidth;

          if (touch.clientX < screenWidth / 2) {
            // Left side of screen
            movePlayerLeft();
          } else {
            // Right side of screen
            movePlayerRight();
          }

          // Check for bomb usage - double tap (implementation simplified)
          if (game.player.bombCount > 0 && e.touches.length >= 2) {
            useBomb();
          }

          e.preventDefault();
        });

        // For testing on desktop
        document.getElementById("game-screen").addEventListener("mousedown", (e) => {
          if (game.state !== "playing") return;

          const screenWidth = document.getElementById("game-screen").clientWidth;

          if (e.clientX < screenWidth / 2) {
            movePlayerLeft();
          } else {
            movePlayerRight();
          }
        });

        // Keyboard controls for testing
        window.addEventListener("keydown", (e) => {
          if (game.state !== "playing") return;

          if (e.key === "ArrowLeft") {
            movePlayerLeft();
          } else if (e.key === "ArrowRight") {
            movePlayerRight();
          } else if (e.key === " " || e.key === "b") {
            // Space or B key to use bomb
            if (game.player.bombCount > 0) {
              useBomb();
            }
          } else if (e.key === "m") {
            // M key to toggle music
            toggleMusic();
          }
        });

        // Window resize
        window.addEventListener("resize", () => {
          const gameScreen = document.getElementById("game-screen");
          config.screenWidth = gameScreen.clientWidth;
          initializeLanes();
          if (game.state === "playing") {
            updatePlayerPosition();
          }
        });
      }

      function movePlayerLeft() {
        if (game.state !== "playing") return;
        if (game.player.lane > 0) {
          game.player.lane--;
          updatePlayerPosition();
          audio.play("move");
          triggerHapticFeedback();
        }
      }

      function movePlayerRight() {
        if (game.state !== "playing") return;
        if (game.player.lane < config.laneCount - 1) {
          game.player.lane++;
          updatePlayerPosition();
          audio.play("move");
          triggerHapticFeedback();
        }
      }

      function updatePlayerPosition() {
        // Set player's horizontal position based on lane
        game.player.x = game.lanes[game.player.lane] - game.player.width / 2;
        game.player.element.style.left = `${game.player.x}px`;
      }

      function useBomb() {
        if (game.player.bombCount <= 0) return;

        // Decrease bomb count
        game.player.bombCount--;
        updateBombDisplay();

        // Create bomb explosion
        const gameScreen = document.getElementById("game-screen");

        const explosion = document.createElement("div");
        explosion.className = "bomb-explosion";
        explosion.style.left = `${game.player.x - config.bombDamageRadius / 2 + game.player.width / 2}px`;
        explosion.style.top = `${game.player.y - config.bombDamageRadius / 2}px`;

        gameScreen.appendChild(explosion);

        // Remove explosion after animation
        setTimeout(() => {
          if (explosion.parentNode) {
            explosion.parentNode.removeChild(explosion);
          }
        }, 500);

        // Destroy enemies within radius
        let enemiesDestroyed = 0;
        const bombCenterX = game.player.x + game.player.width / 2;
        const bombCenterY = game.player.y;

        for (let i = game.enemies.length - 1; i >= 0; i--) {
          const enemy = game.enemies[i];
          const enemyCenterX = enemy.x + enemy.width / 2;
          const enemyCenterY = enemy.y + enemy.height / 2;

          // Calculate distance between bomb and enemy
          const dx = bombCenterX - enemyCenterX;
          const dy = bombCenterY - enemyCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // If within radius, destroy enemy
          if (distance <= config.bombDamageRadius) {
            handleEnemyDefeat(enemy, i);
            enemiesDestroyed++;

            // Limit to 8 enemies maximum (increased from 5)
            if (enemiesDestroyed >= 8) break;
          }
        }

        // Sound and haptic feedback
        audio.play("bomb");
        triggerHapticFeedback();

        // Create score popup - reduced from 20 to 10 per enemy
        createScorePopup(game.player.x, game.player.y - 20, `BOMB! +${enemiesDestroyed * 10}`);

        // Add score - reduced from 20 to 10 per enemy
        game.score += enemiesDestroyed * 10;
      }

      function startGame() {
        document.getElementById("start-screen").style.display = "none";
        resetGameState();
        createInitialWave();

        game.player.element = document.getElementById("player");
        const gameScreen = document.getElementById("game-screen");
        game.player.y = gameScreen.clientHeight - game.player.height - 40;

        // Set player in the middle lane
        game.player.lane = Math.floor(config.laneCount / 2);
        updatePlayerPosition();

        game.player.element.style.bottom = "40px";

        updateHealthBar();
        updateWeaponDisplay();
        updateBombDisplay();
        updateWaveDisplay();

        // Start background music if not muted
        if (!game.musicMuted) {
          bgMusic.play().catch((err) => console.log("Music start failed:", err));
        }

        game.lastUpdateTime = performance.now();
        game.state = "playing";
        gameLoop();
      }

      function resetGameState() {
        game.score = 0;
        game.distance = 0;
        game.currentDistance = 0;
        game.enemiesDefeated = 0;
        game.health = config.playerHealth;
        game.wave = 1;
        game.lastWaveChange = 0;
        game.hasEnemies = false;
        game.player.moving = false;
        game.allEnemiesDefeated = false;
        game.player.weaponLevel = 1;
        game.player.bombCount = 1; // Start with 1 bomb

        updateScoreDisplay();
        updateWaveDisplay();
        updateHealthBar();
        updateWeaponDisplay();
        updateBombDisplay();

        // Clean up existing elements
        clearGameElements();

        game.player.shielded = false;
        game.player.invincible = false;
        document.getElementById("shield").style.display = "none";

        game.allies = [];
        game.enemies = [];
        game.bullets = [];
        game.enemyBullets = [];
        game.powerUps = [];
        game.particles = [];

        if (game.shieldTimer) clearTimeout(game.shieldTimer);

        // Reset lane position
        game.player.lane = Math.floor(config.laneCount / 2);
      }

      function clearGameElements() {
        const gameScreen = document.getElementById("game-screen");
        const elements = gameScreen.querySelectorAll(
          ".enemy, .ally, .bullet, .enemy-bullet, .power-up, .explosion, .particle, .wave-notification, .score-popup, .bomb-explosion",
        );
        elements.forEach((element) => element.remove());
      }

      function createInitialWave() {
        // Display wave notification
        showNotification(`WAVE ${game.wave} INCOMING!`);

        audio.play("newWave");
        triggerHapticFeedback();

        // Spawn initial enemies
        setTimeout(() => {
          for (let i = 0; i < config.enemyCount.initial; i++) {
            createEnemy();
          }
          game.hasEnemies = true;
        }, 1000);
      }

      function showNotification(message) {
        const gameScreen = document.getElementById("game-screen");
        const notification = document.createElement("div");
        notification.className = "wave-notification";
        notification.textContent = message;
        gameScreen.appendChild(notification);

        // Remove notification after animation completes
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 2000);
      }

      function advanceWave() {
        game.wave++;
        game.lastWaveChange = game.distance;
        game.currentDistance = 0;
        updateWaveDisplay();

        showNotification(`WAVE ${game.wave} INCOMING!`);
        audio.play("newWave");
        triggerHapticFeedback();

        // Increase enemy count based on wave
        const enemyCount = Math.min(
          config.enemyCount.initial + (game.wave - 1) * config.enemyCount.incrementPerWave,
          config.enemyCount.max,
        );

        // Spawn enemies over time
        const spawnDelay = 250; // Decreased from 300 for faster spawn
        for (let i = 0; i < enemyCount; i++) {
          setTimeout(
            () => {
              if (game.state === "playing") {
                createEnemy();
              }
            },
            1000 + i * spawnDelay,
          );
        }

        // Spawn a guaranteed power-up after each wave
        setTimeout(
          () => {
            if (game.state === "playing") {
              // Determine what power-up to spawn based on needs
              let powerUpType;

              if (game.health < config.playerHealth / 2) {
                powerUpType = "health";
              } else if (game.player.bombCount === 0) {
                powerUpType = "bomb";
              } else if (game.allies.length < config.maxAllies / 2) {
                // Prioritize allies
                powerUpType = "ally";
              } else if (game.player.weaponLevel < 3 && game.wave >= 2) {
                powerUpType = "weapon";
              } else {
                powerUpType = "shield";
              }

              createPowerUp(null, null, powerUpType);
            }
          },
          1000 + enemyCount * spawnDelay + 500,
        );

        // Set enemies flag
        game.hasEnemies = true;
        game.player.moving = false;
        game.allEnemiesDefeated = false;
      }

      function createEnemy() {
        const gameScreen = document.getElementById("game-screen");

        // Determine enemy type based on wave and randomness
        let enemyType = "normal";
        const typeRandom = Math.random();

        if (game.wave >= 4) {
          if (typeRandom < 0.3) enemyType = "normal";
          else if (typeRandom < 0.6) enemyType = "fast";
          else if (typeRandom < 0.85) enemyType = "zigzag";
          else enemyType = "tough";
        } else if (game.wave >= 2) {
          if (typeRandom < 0.5) enemyType = "normal";
          else if (typeRandom < 0.8) enemyType = "fast";
          else enemyType = "zigzag";
        }

        // Choose a random lane
        const laneIndex = Math.floor(Math.random() * config.laneCount);

        // Create enemy at the top of the screen in the chosen lane
        const x = game.lanes[laneIndex] - 10; // Center in lane
        const y = -30; // Start off-screen

        const enemy = {
          x: x,
          y: y,
          width: 20,
          height: 20,
          type: enemyType,
          lane: laneIndex,
          health: config.enemyHealth[enemyType],
          maxHealth: config.enemyHealth[enemyType],
          velocityY:
            config.enemySpeed * (enemyType === "fast" ? 1.5 : 1) * Math.pow(config.difficultyMultiplier, game.wave - 1),
          shootTimer: Math.floor(Math.random() * 120),
          zigzagCounter: 0,
          element: document.createElement("div"),
          healthBarContainer: null,
          healthBar: null,
        };

        enemy.element.className = "enemy";
        enemy.element.style.left = `${enemy.x}px`;
        enemy.element.style.top = `${enemy.y}px`;

        // Visual differences based on enemy type
        if (enemyType === "fast") {
          enemy.element.style.backgroundColor = "#ff8800";
          enemy.element.style.height = "16px";
        } else if (enemyType === "tough") {
          enemy.element.style.backgroundColor = "#880000";
          enemy.element.style.width = "24px";
          enemy.element.style.height = "24px";
        } else if (enemyType === "zigzag") {
          enemy.element.style.backgroundColor = "#ff00ff";
          enemy.element.style.borderRadius = "0";
        }

        // Add health bar for enemies with more than 1 health
        if (enemy.maxHealth > 1) {
          const healthBarContainer = document.createElement("div");
          healthBarContainer.className = "health-bar-container";

          const healthBar = document.createElement("div");
          healthBar.className = "health-bar";

          healthBarContainer.appendChild(healthBar);
          enemy.element.appendChild(healthBarContainer);

          enemy.healthBarContainer = healthBarContainer;
          enemy.healthBar = healthBar;
        }

        gameScreen.appendChild(enemy.element);
        game.enemies.push(enemy);
      }

      function createBullet() {
        const gameScreen = document.getElementById("game-screen");

        const bullet = {
          x: game.player.x + game.player.width / 2 - 2,
          y: game.player.y - 10,
          width: 4,
          height: 10,
          velocityY: -config.bulletSpeed,
          element: document.createElement("div"),
          damage: config.bulletDamage[game.player.weaponLevel] || 1,
        };

        // Different bullet styles based on weapon level
        bullet.element.className = `bullet${game.player.weaponLevel > 1 ? " level" + game.player.weaponLevel : ""}`;
        bullet.element.style.left = `${bullet.x}px`;
        bullet.element.style.top = `${bullet.y}px`;

        gameScreen.appendChild(bullet.element);
        game.bullets.push(bullet);

        audio.play("shoot");
      }

      function createAlly() {
        if (game.allies.length >= config.maxAllies) return;

        const gameScreen = document.getElementById("game-screen");

        // Choose position based on current allies
        const allyPosition = game.allies.length;
        let x, y;

        // Position allies in formation behind player
        if (allyPosition % 2 === 0) {
          // Right side
          x = game.player.x + game.player.width + 10 + Math.floor(allyPosition / 2) * 15;
          y = game.player.y + 10 + Math.floor(allyPosition / 2) * 20;
        } else {
          // Left side
          x = game.player.x - 10 - 16 - Math.floor(allyPosition / 2) * 15;
          y = game.player.y + 10 + Math.floor(allyPosition / 2) * 20;
        }

        const ally = {
          x: x,
          y: y,
          width: 16,
          height: 16,
          position: allyPosition,
          shootTimer: Math.floor(Math.random() * 60),
          element: document.createElement("div"),
        };

        ally.element.className = "ally";
        ally.element.style.left = `${ally.x}px`;
        ally.element.style.top = `${ally.y}px`;

        gameScreen.appendChild(ally.element);
        game.allies.push(ally);

        audio.play("newAlly");
        triggerHapticFeedback();
      }

      function createEnemyBullet(enemy) {
        const gameScreen = document.getElementById("game-screen");

        const bullet = {
          x: enemy.x + enemy.width / 2 - 2,
          y: enemy.y + enemy.height,
          width: 4,
          height: 8,
          velocityY: config.enemyBulletSpeed,
          element: document.createElement("div"),
        };

        bullet.element.className = "enemy-bullet";
        bullet.element.style.left = `${bullet.x}px`;
        bullet.element.style.top = `${bullet.y}px`;

        gameScreen.appendChild(bullet.element);
        game.enemyBullets.push(bullet);

        audio.play("enemyShoot");
      }

      function createPowerUp(x, y, forcedType = null) {
        const gameScreen = document.getElementById("game-screen");

        // If position not specified, pick a random lane
        if (x === null || y === null) {
          const laneIndex = Math.floor(Math.random() * config.laneCount);
          x = game.lanes[laneIndex] - 8; // Center in lane
          y = -20; // Start off-screen
        }

        // Determine power-up type based on game state
        let powerUpType;

        if (forcedType) {
          powerUpType = forcedType;
        } else {
          const typeRandom = Math.random();

          if (game.health < config.playerHealth / 3) {
            // Higher chance for health only when critically low
            if (typeRandom < 0.35) powerUpType = "health";
            else if (typeRandom < 0.55) powerUpType = "shield";
            else if (typeRandom < 0.85)
              powerUpType = "ally"; // Increased ally chance
            else if (typeRandom < 0.95) powerUpType = "weapon";
            else powerUpType = "bomb";
          } else {
            // Normal distribution (prioritize allies over other power-ups)
            if (typeRandom < 0.45)
              powerUpType = "ally"; // Highest chance for allies
            else if (typeRandom < 0.65) powerUpType = "shield";
            else if (typeRandom < 0.75)
              powerUpType = "health"; // Lower chance for health
            else if (typeRandom < 0.9) powerUpType = "weapon";
            else powerUpType = "bomb";
          }
        }

        const powerUp = {
          x: x,
          y: y,
          width: 16,
          height: 16,
          type: powerUpType,
          velocityY: config.enemySpeed / 1.5, // Slower than enemies
          element: document.createElement("div"),
        };

        powerUp.element.className = `power-up ${powerUpType}`;
        powerUp.element.style.left = `${powerUp.x}px`;
        powerUp.element.style.top = `${powerUp.y}px`;

        gameScreen.appendChild(powerUp.element);
        game.powerUps.push(powerUp);
      }

      function createExplosion(x, y, size = 30) {
        const gameScreen = document.getElementById("game-screen");

        const explosion = document.createElement("div");
        explosion.className = "explosion";
        explosion.style.left = `${x - size / 2}px`;
        explosion.style.top = `${y - size / 2}px`;
        explosion.style.width = `${size}px`;
        explosion.style.height = `${size}px`;

        gameScreen.appendChild(explosion);

        // Remove explosion element after animation completes
        setTimeout(() => {
          if (explosion.parentNode) {
            explosion.parentNode.removeChild(explosion);
          }
        }, 300);

        // Create particles for added effect
        createExplosionParticles(x, y, 10);
      }

      function createExplosionParticles(x, y, count) {
        const gameScreen = document.getElementById("game-screen");

        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 1;

          const particle = {
            x: x,
            y: y,
            velocityX: Math.cos(angle) * speed,
            velocityY: Math.sin(angle) * speed,
            life: 30,
            element: document.createElement("div"),
          };

          particle.element.className = "particle";
          particle.element.style.left = `${particle.x}px`;
          particle.element.style.top = `${particle.y}px`;

          gameScreen.appendChild(particle.element);
          game.particles.push(particle);
        }
      }

      function createScorePopup(x, y, amount) {
        const gameScreen = document.getElementById("game-screen");

        const popup = document.createElement("div");
        popup.className = "score-popup";
        popup.textContent = amount;
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`;

        gameScreen.appendChild(popup);

        // Remove popup after animation completes
        setTimeout(() => {
          if (popup.parentNode) {
            popup.parentNode.removeChild(popup);
          }
        }, 1000);
      }

      function createStars() {
        const gameScreen = document.getElementById("game-screen");
        const screenWidth = gameScreen.clientWidth;
        const screenHeight = gameScreen.clientHeight;

        for (let i = 0; i < config.starCount; i++) {
          const star = document.createElement("div");
          star.className = "star";

          const x = Math.random() * screenWidth;
          const y = Math.random() * screenHeight;
          const size = Math.random() * 2 + 1;
          const opacity = Math.random() * 0.5 + 0.3;

          star.style.left = `${x}px`;
          star.style.top = `${y}px`;
          star.style.width = `${size}px`;
          star.style.height = `${size}px`;
          star.style.opacity = opacity;

          gameScreen.appendChild(star);
          game.stars.push({
            element: star,
            x: x,
            y: y,
            speed: Math.random() * 0.3 + 0.1,
          });
        }
      }

      function gameLoop(timestamp) {
        if (game.state !== "playing") return;

        const deltaTime = timestamp - game.lastUpdateTime;
        game.lastUpdateTime = timestamp;

        // Auto-shoot if there are enemies
        if (
          game.hasEnemies &&
          timestamp - game.lastAutoShoot >
            config.autoShootDelay / (game.player.weaponLevel === 3 ? 1.5 : game.player.weaponLevel === 2 ? 1.2 : 1)
        ) {
          createBullet();
          game.lastAutoShoot = timestamp;
        }

        // Update game elements
        updateEnemies();
        updateBullets();
        updateEnemyBullets();
        updatePowerUps();
        updateParticles();
        updateStars();
        updateAllies();

        // Check if all enemies are defeated
        if (game.hasEnemies && game.enemies.length === 0) {
          game.hasEnemies = false;
          game.allEnemiesDefeated = true;
          showNotification("Area Cleared!");

          // Add bonus score for clearing wave (reduced from 50 to 25 per wave)
          const waveClearBonus = game.wave * config.waveClearBonusMultiplier;
          game.score += waveClearBonus;
          createScorePopup(game.player.x, game.player.y - 40, `WAVE BONUS +${waveClearBonus}`);

          // Give player a short break before advancing
          setTimeout(() => {
            if (game.state === "playing" && game.allEnemiesDefeated) {
              game.player.moving = true;
              showNotification("Advancing to next area...");
            }
          }, 2000);
        }

        // Update player movement
        if (game.player.moving) {
          game.currentDistance += config.progressSpeed;
          game.distance += config.progressSpeed;

          // Check if we should advance to next wave
          if (game.currentDistance >= config.waveAdvanceDistance) {
            advanceWave();
          }
        }

        // Random power-up chance (only while enemies are present)
        if (Math.random() < config.powerUpChance / 100 && game.hasEnemies) {
          createPowerUp();
        }

        // Update score display
        updateScoreDisplay();

        // Request next frame
        game.animationFrameId = requestAnimationFrame(gameLoop);
      }

      function updateEnemies() {
        // Reset flag, we'll set it if we find live enemies
        game.hasEnemies = game.enemies.length > 0;

        const gameScreen = document.getElementById("game-screen");
        const screenHeight = gameScreen.clientHeight;

        for (let i = game.enemies.length - 1; i >= 0; i--) {
          const enemy = game.enemies[i];

          // Move enemy down
          enemy.y += enemy.velocityY;

          // Handle zigzag movement
          if (enemy.type === "zigzag") {
            enemy.zigzagCounter += 0.05;
            enemy.x += Math.sin(enemy.zigzagCounter) * 2;

            // Update lane based on position
            const closestLane = game.lanes.reduce(
              (prev, curr, idx) => {
                const prevDist = Math.abs(prev.pos - enemy.x);
                const currDist = Math.abs(curr - enemy.x);
                return currDist < prevDist ? { pos: curr, idx: idx } : prev;
              },
              { pos: game.lanes[0], idx: 0 },
            );

            enemy.lane = closestLane.idx;
          }

          // Update enemy position
          enemy.element.style.left = `${enemy.x}px`;
          enemy.element.style.top = `${enemy.y}px`;

          // Enemy shooting
          enemy.shootTimer++;
          let shootChance = config.enemyShootChance * Math.pow(config.difficultyMultiplier, game.wave - 1);

          // Increase difficulty after wave 3
          if (game.wave >= 3) {
            shootChance *= 1.2;
          }

          if (enemy.shootTimer > 120 && Math.random() < shootChance) {
            createEnemyBullet(enemy);
            enemy.shootTimer = 0;
          }

          // Remove if off screen
          if (enemy.y > screenHeight + 50) {
            enemy.element.remove();
            game.enemies.splice(i, 1);
            continue;
          }

          // Check collision with player
          if (checkCollision(enemy, game.player)) {
            if (game.player.shielded) {
              // Shield absorbs damage
              enemy.health -= 1;

              // Update enemy health bar if it exists
              if (enemy.healthBar) {
                const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                enemy.healthBar.style.width = `${healthPercent}%`;
              }

              // Push enemy back
              enemy.y -= 30;

              if (enemy.health <= 0) {
                handleEnemyDefeat(enemy, i);
              }
            } else if (!game.player.invincible) {
              // Player takes damage
              const damageMultiplier = game.wave >= 3 ? config.damageMultiplierAfterWave3 : 1;
              takeDamage(config.baseEnemyDamage * damageMultiplier);

              // Push enemy back
              enemy.y -= 20;
            }
          }
        }
      }

      function updateBullets() {
        const gameScreen = document.getElementById("game-screen");

        for (let i = game.bullets.length - 1; i >= 0; i--) {
          const bullet = game.bullets[i];

          // Move bullet
          bullet.y += bullet.velocityY;

          // Update bullet position
          bullet.element.style.top = `${bullet.y}px`;

          // Remove if off screen
          if (bullet.y < -bullet.height) {
            bullet.element.remove();
            game.bullets.splice(i, 1);
            continue;
          }

          // Check collision with enemies
          let hitEnemy = false;
          for (let j = game.enemies.length - 1; j >= 0; j--) {
            const enemy = game.enemies[j];

            if (checkCollision(bullet, enemy)) {
              // Damage enemy
              enemy.health -= bullet.damage;

              // Update enemy health bar if it exists
              if (enemy.healthBar) {
                const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                enemy.healthBar.style.width = `${healthPercent}%`;
              }

              // Check if enemy is defeated
              if (enemy.health <= 0) {
                handleEnemyDefeat(enemy, j);
              } else {
                // Just flash to show damage
                enemy.element.style.opacity = 0.5;
                setTimeout(() => {
                  if (enemy.element) {
                    enemy.element.style.opacity = 1;
                  }
                }, 100);
              }

              // Remove bullet
              bullet.element.remove();
              game.bullets.splice(i, 1);

              hitEnemy = true;
              break;
            }
          }

          if (hitEnemy) {
            continue;
          }
        }
      }

      function handleEnemyDefeat(enemy, index) {
        // Get score based on enemy type - now reduced values
        const scoreValue = config.scoreValues[enemy.type] || config.scoreValues.normalEnemy;

        // Update score and count
        game.score += scoreValue;
        game.enemiesDefeated++;

        // Visual effects
        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
        createScorePopup(enemy.x, enemy.y, `+${scoreValue}`);

        // Sound effect
        audio.play("hit");
        triggerHapticFeedback();

        // Check for dropping power-ups - use combined probability
        const dropRoll = Math.random();
        const totalDropChance =
          config.healthDropChance +
          config.shieldDropChance +
          config.weaponUpgradeChance +
          config.bombDropChance +
          config.allyDropChance;

        // Use running sum to determine what drops
        let runningSum = 0;

        // Check for ally drops (highest priority)
        runningSum += config.allyDropChance;
        if (dropRoll < runningSum && game.allies.length < config.maxAllies) {
          createPowerUp(enemy.x + enemy.width / 2 - 8, enemy.y, "ally");
        }
        // Then shield drops
        else if (dropRoll < (runningSum += config.shieldDropChance)) {
          createPowerUp(enemy.x + enemy.width / 2 - 8, enemy.y, "shield");
        }
        // Then weapon upgrades
        else if (dropRoll < (runningSum += config.weaponUpgradeChance) && game.player.weaponLevel < 3) {
          createPowerUp(enemy.x + enemy.width / 2 - 8, enemy.y, "weapon");
        }
        // Then health drops
        else if (dropRoll < (runningSum += config.healthDropChance)) {
          createPowerUp(enemy.x + enemy.width / 2 - 8, enemy.y, "health");
        }
        // Finally bomb drops
        else if (dropRoll < (runningSum += config.bombDropChance)) {
          createPowerUp(enemy.x + enemy.width / 2 - 8, enemy.y, "bomb");
        }

        // Remove enemy
        enemy.element.remove();
        game.enemies.splice(index, 1);
      }

      function updateEnemyBullets() {
        const gameScreen = document.getElementById("game-screen");
        const screenHeight = gameScreen.clientHeight;

        for (let i = game.enemyBullets.length - 1; i >= 0; i--) {
          const bullet = game.enemyBullets[i];

          // Move bullet
          bullet.y += bullet.velocityY;

          // Update bullet position
          bullet.element.style.top = `${bullet.y}px`;

          // Remove if off screen
          if (bullet.y > screenHeight) {
            bullet.element.remove();
            game.enemyBullets.splice(i, 1);
            continue;
          }

          // Check collision with player
          if (checkCollision(bullet, game.player)) {
            // Remove bullet
            bullet.element.remove();
            game.enemyBullets.splice(i, 1);

            if (game.player.shielded) {
              // Shield absorbs the hit
              createExplosion(bullet.x, bullet.y, 15);
            } else if (!game.player.invincible) {
              // Player takes damage - adjust difficulty based on wave
              const damageMultiplier = game.wave >= 3 ? config.damageMultiplierAfterWave3 : 1;
              takeDamage((config.baseEnemyDamage / 2) * damageMultiplier);
              createExplosion(bullet.x, bullet.y, 15);
            }
          }

          // Check collision with allies
          for (let j = game.allies.length - 1; j >= 0; j--) {
            const ally = game.allies[j];

            if (checkCollision(bullet, ally)) {
              // Remove bullet
              bullet.element.remove();
              game.enemyBullets.splice(i, 1);

              // Create explosion
              createExplosion(ally.x + ally.width / 2, ally.y + ally.height / 2, 15);

              // Remove ally
              ally.element.remove();
              game.allies.splice(j, 1);
              break;
            }
          }
        }
      }

      function updatePowerUps() {
        const gameScreen = document.getElementById("game-screen");
        const screenHeight = gameScreen.clientHeight;

        for (let i = game.powerUps.length - 1; i >= 0; i--) {
          const powerUp = game.powerUps[i];

          // Move power-up
          powerUp.y += powerUp.velocityY;

          // Update position
          powerUp.element.style.top = `${powerUp.y}px`;

          // Remove if off screen
          if (powerUp.y > screenHeight) {
            powerUp.element.remove();
            game.powerUps.splice(i, 1);
            continue;
          }

          // Check collision with player
          if (checkCollision(powerUp, game.player)) {
            // Apply power-up effect
            applyPowerUp(powerUp.type);

            // Visual and sound effects
            createExplosion(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, 20);
            audio.play("powerUp");
            triggerHapticFeedback();

            // Remove power-up
            powerUp.element.remove();
            game.powerUps.splice(i, 1);
          }
        }
      }

      function applyPowerUp(type) {
        switch (type) {
          case "health":
            // Restore health
            game.health = Math.min(game.health + 25, config.playerHealth);
            updateHealthBar();
            createScorePopup(game.player.x, game.player.y - 20, "HEALTH +25");
            break;

          case "shield":
            // Activate shield
            activateShield();
            createScorePopup(game.player.x, game.player.y - 20, "SHIELD");
            break;

          case "ally":
            // Add ally
            if (game.allies.length < config.maxAllies) {
              createAlly();
              createScorePopup(game.player.x, game.player.y - 20, "ALLY");
            } else {
              // If max allies reached, give score instead
              game.score += 20; // Reduced from 30 to align with score rebalancing
              createScorePopup(game.player.x, game.player.y - 20, "+20 SCORE");
            }
            break;

          case "weapon":
            // Upgrade weapon
            if (game.player.weaponLevel < 3) {
              game.player.weaponLevel++;
              updateWeaponDisplay();
              createScorePopup(game.player.x, game.player.y - 20, `WEAPON LV.${game.player.weaponLevel}`);
              audio.play("upgrade");
            } else {
              // Already max level, give score instead
              game.score += 20; // Reduced from 50 to align with score rebalancing
              createScorePopup(game.player.x, game.player.y - 20, "+20 SCORE");
            }
            break;

          case "bomb":
            // Add bomb
            game.player.bombCount++;
            updateBombDisplay();
            createScorePopup(game.player.x, game.player.y - 20, "BOMB");
            break;
        }

        // Add score for collecting power-up
        game.score += 5; // Reduced from 15 to align with score rebalancing
      }

      function activateShield() {
        if (game.shieldTimer) clearTimeout(game.shieldTimer);

        game.player.shielded = true;
        document.getElementById("shield").style.display = "block";

        game.shieldTimer = setTimeout(() => {
          game.player.shielded = false;
          document.getElementById("shield").style.display = "none";
        }, config.shieldDuration);
      }

      function updateParticles() {
        for (let i = game.particles.length - 1; i >= 0; i--) {
          const particle = game.particles[i];

          // Move particle
          particle.x += particle.velocityX;
          particle.y += particle.velocityY;

          // Decrease life
          particle.life--;

          // Update position
          particle.element.style.left = `${particle.x}px`;
          particle.element.style.top = `${particle.y}px`;

          // Fade out
          particle.element.style.opacity = particle.life / 30;

          // Remove if life is over
          if (particle.life <= 0) {
            particle.element.remove();
            game.particles.splice(i, 1);
          }
        }
      }

      function updateStars() {
        // Only update stars when player is moving
        if (!game.player.moving) return;

        const gameScreen = document.getElementById("game-screen");
        const screenHeight = gameScreen.clientHeight;

        for (let i = 0; i < game.stars.length; i++) {
          const star = game.stars[i];

          // Move star down to create forward motion effect
          star.y += star.speed * 5;

          // Reset if off screen
          if (star.y > screenHeight) {
            star.y = 0;
            star.x = Math.random() * gameScreen.clientWidth;
          }

          // Update position
          star.element.style.top = `${star.y}px`;
        }
      }

      function updateAllies() {
        // Skip if no allies
        if (game.allies.length === 0) return;

        for (let i = 0; i < game.allies.length; i++) {
          const ally = game.allies[i];

          // Update ally positions based on player position
          const allyPosition = i;

          if (allyPosition % 2 === 0) {
            // Right side
            ally.x = game.player.x + game.player.width + 10 + Math.floor(allyPosition / 2) * 15;
            ally.y = game.player.y + 10 + Math.floor(allyPosition / 2) * 20;
          } else {
            // Left side
            ally.x = game.player.x - 10 - ally.width - Math.floor(allyPosition / 2) * 15;
            ally.y = game.player.y + 10 + Math.floor(allyPosition / 2) * 20;
          }

          // Update position
          ally.element.style.left = `${ally.x}px`;
          ally.element.style.top = `${ally.y}px`;

          // Shoot occasionally if enemies exist
          if (game.hasEnemies) {
            ally.shootTimer++;

            if (ally.shootTimer > 90) {
              // Less frequent than player
              // Create ally bullet
              createAllyBullet(ally);
              ally.shootTimer = 0;
            }
          }
        }
      }

      function createAllyBullet(ally) {
        const gameScreen = document.getElementById("game-screen");

        const bullet = {
          x: ally.x + ally.width / 2 - 2,
          y: ally.y - 10,
          width: 4,
          height: 10,
          velocityY: -config.bulletSpeed,
          element: document.createElement("div"),
          damage: 1, // Allies always do base damage
        };

        bullet.element.className = "bullet";
        bullet.element.style.backgroundColor = "#88ff88"; // Different color for ally bullets
        bullet.element.style.left = `${bullet.x}px`;
        bullet.element.style.top = `${bullet.y}px`;

        gameScreen.appendChild(bullet.element);
        game.bullets.push(bullet);
      }

      function takeDamage(amount) {
        if (game.player.invincible) return;

        game.health -= amount;
        updateHealthBar();

        // Visual and sound effects
        audio.play("playerHit");
        triggerHapticFeedback();

        const gameScreen = document.getElementById("game-screen");
        gameScreen.classList.add("flash");
        setTimeout(() => {
          gameScreen.classList.remove("flash");
        }, 200);

        // Make player briefly invincible
        game.player.invincible = true;
        game.player.element.style.opacity = 0.5;

        setTimeout(() => {
          game.player.invincible = false;
          game.player.element.style.opacity = 1;
        }, config.invincibilityTime);

        // Check if player has lost all health
        if (game.health <= 0) {
          endGame();
        }
      }

      function updateHealthBar() {
        const healthBar = document.getElementById("health-bar");
        const healthPercent = (game.health / config.playerHealth) * 100;
        healthBar.style.width = `${healthPercent}%`;

        // Change color based on health remaining
        if (healthPercent > 60) {
          healthBar.style.backgroundColor = "#00ff00"; // Green
        } else if (healthPercent > 30) {
          healthBar.style.backgroundColor = "#ffff00"; // Yellow
        } else {
          healthBar.style.backgroundColor = "#ff0000"; // Red
        }
      }

      function updateWeaponDisplay() {
        document.getElementById("weapon-container").textContent = `WEAPON: LV.${game.player.weaponLevel}`;
      }

      function updateBombDisplay() {
        document.getElementById("bomb-container").textContent = `BOMBS: ${game.player.bombCount}`;
      }

      function updateScoreDisplay() {
        document.getElementById("score-container").textContent = `SCORE: ${Math.floor(game.score)}`;
      }

      function updateWaveDisplay() {
        document.getElementById("wave-container").textContent = `WAVE: ${game.wave}`;
      }

      function checkCollision(obj1, obj2) {
        return (
          obj1.x < obj2.x + obj2.width &&
          obj1.x + obj1.width > obj2.x &&
          obj1.y < obj2.y + obj2.height &&
          obj1.y + obj1.height > obj2.y
        );
      }

      function endGame() {
        game.state = "gameOver";
        cancelAnimationFrame(game.animationFrameId);

        // Stop background music
        bgMusic.pause();

        // Display game over screen
        const gameOverScreen = document.getElementById("game-over-screen");
        document.getElementById("final-score").textContent = `FINAL SCORE: ${Math.floor(game.score)}`;
        document.getElementById("enemies-defeated").textContent = `ENEMIES DEFEATED: ${game.enemiesDefeated}`;
        document.getElementById("wave-reached").textContent = `WAVE REACHED: ${game.wave}`;
        gameOverScreen.style.display = "flex";

        audio.play("gameOver");

        // Send score to Farcade
        if (game.farcadeInitialized && window.FarcadeSDK) {
          try {
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: Math.floor(game.score) });
          } catch (e) {
            console.warn("Farcade gameOver failed:", e);
          }
        }
      }

      function restartGame() {
        document.getElementById("game-over-screen").style.display = "none";
        startGame();
      }

      window.addEventListener("DOMContentLoaded", initGame);
    </script>
  </body>
</html>
